package edu.duke.yl883.battleship;

import java.io.BufferedReader;
import java.io.EOFException;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.function.Function;

/** Player pattern in text mode */
public abstract class TextUser {
  /**
   * theBoard is the my own Board for the App
   * enemyBoard is the enemy Board for the App
   * view is the Text view of the board
   * enemyView is the Text view of the enemy board
   * inputReader is a bufferedReader of the App
   * out is the stream to be printed to
   * shipFactory is object to make ship
   */
  final Board<Character> theBoard;
  Board<Character> enemyBoard;
  final BoardTextView view, enemyView;
  final BufferedReader inputReader;
  final PrintStream out;
  final AbstractShipFactory<Character> shipFactory;
  final String name;
  /** ArrayList of the ships' name*/
  final ArrayList<String> shipsToPlace;
  /** A map from ship name to the lambda 
   * takes a placement and return a Ship
   */
  final HashMap<String, Function<Placement, Ship<Character>>> shipCreationFns;
  /** A map from ship name to whether it is a version
   * 2 special ship
   */
  final HashMap<String, Boolean> shipCreationVersion;
  /** Number of uses remaining for move ship
   *  and sonar scan
   */
  int moveShipNum, sonarScanNum;
  /** Whether this player is selected for the game*/
  final boolean selected;

  /**
   * Construct the textplayer with specfied name, board,
   * BufferedReader, PrintStream and factory
   * @param name is name of the player
   * @param theBoard    is board used for current player
   * @param input is the input reader for current player
   * @param out         is the out stream for current player
   * @param f is version 1 ship factory of current player
   * @param isComputer indicate whether this player is computer 
   */
  public TextUser(String name, Board<Character> theBoard, BufferedReader input, PrintStream out, V2ShipFactory f, Board<Character> enemyBoard) {
    this.name = name;
    this.theBoard = theBoard;
    this.enemyBoard = enemyBoard;
    this.view = new BoardTextView(theBoard);
    this.enemyView = new BoardTextView(enemyBoard);
    this.inputReader = input;
    this.out = out;
    this.shipFactory = f;
    this.selected = false;
    this.shipsToPlace = new ArrayList<String>();
    this.shipCreationFns = new HashMap<String, Function<Placement, Ship<Character>>>();
    this.shipCreationVersion = new HashMap<String, Boolean>();
    this.moveShipNum = 2;
    this.sonarScanNum = 1;
    setupShipCreationBool();
    setupShipCreationMap();
    setupShipCreationList();
  }
  /** Set up the shipCreationFns Hashmap*/
  protected void setupShipCreationMap() {
    shipCreationFns.put("Submarine", (p) -> shipFactory.makeSubmarine(p));
    shipCreationFns.put("Battleship", (p) -> shipFactory.makeBattleship(p));
    shipCreationFns.put("Carrier", (p) -> shipFactory.makeCarrier(p));
    shipCreationFns.put("Destroyer", (p) -> shipFactory.makeDestroyer(p));
  }
  /** Set up the ship name ArrayList*/
  protected void setupShipCreationList() {
     shipsToPlace.addAll(Collections.nCopies(2, "Submarine"));
     shipsToPlace.addAll(Collections.nCopies(3, "Destroyer"));
     shipsToPlace.addAll(Collections.nCopies(3, "Battleship"));
     shipsToPlace.addAll(Collections.nCopies(2, "Carrier"));
  }
  /** Set up the shipCreationVersion Hashmap*/
  protected void setupShipCreationBool() {
    shipCreationVersion.put("Submarine", false);
    shipCreationVersion.put("Battleship", true);
    shipCreationVersion.put("Carrier", true);
    shipCreationVersion.put("Destroyer", false);
  }
  /** set the enemyBoard
   * @param enemy is enemybord to be set*/
  public void setEnemyBoard(Board<Character> enemy) {
    enemyBoard = enemy;
  }
  /** get own board
   * @return theBoard*/
  public Board<Character> getOwnBoard() {
    return theBoard;
  }
  /**
   * Decide whether this player is select 
   * for current game
   * @return true if select, false otherwise
   */
  public boolean doPlayerSelection() throws IOException{
    out.println("Do you want to select " + name + " in this game?\n");
    out.println("Y yes\n" + "N no\n");
    String s = inputReader.readLine();
    if(s.equals("Y")) return true;
    else if(s.equals("N")) return false;
    else {
      out.println("Invalid choice number " + s);
      return doPlayerSelection();
    }
  }
  /**
   * Check for the win/lose of the player
   * @return true if this player win
   *        false if not win yet 
   */
  public boolean isWin() {
    if(enemyBoard.loseCheck()) {
      out.println("Player " + name + " win the game!");
      return true;
    }
    return false;
  }

  
  /**
   * Rotate the coordinate of all pieces
   * on the ship to default: 'V' for version1
   * 'U' for version2
   * @param s is the ship to be handled
   */    
  public Ship<Character> defaultOriShip(Ship<Character> s) {
    char ori = s.getOrientation();
    Coordinate origin = new Coordinate(0, 0);
    if(ori == 'R') return shipAfterMove(s, s.getTopLeft(), 'L');
    if(s.getOrientation() == 'D') return shipAfterMove(s, s.getTopLeft(), 'D');
    if(s.getOrientation() == 'L' || ori == 'H') return shipAfterMove(s, s.getTopLeft(), 'R');
    return s;
  }
  /**
   * Update the coordinate change of all pieces
   * on the ship
   * @param s is the ship to be handled
   * @param newCoordinate is the new top left corner
   * @param ori is the relative orientation between
   * the new and old orientation
   */    
  public Ship<Character> shipAfterMove(Ship<Character> s, Coordinate newCoordinate, char ori) {
    Coordinate topLeft = s.getTopLeft();
    V2ShipFactory f = new V2ShipFactory();
    int width = s.getDiagonal().getColumn() - topLeft.getColumn();
    int length = s.getDiagonal().getRow() - topLeft.getRow();
    char sign = ' ';
    HashMap<Coordinate, Boolean> newCoords = new HashMap<>();
    for(Coordinate c : s.getCoordinates()) {
      if(!s.wasHitAt(c)) sign = s.getDisplayInfoAt(c, true);
      Coordinate modify = new Coordinate(c.getRow() - topLeft.getRow(), c.getColumn() - topLeft.getColumn());
      //      System.out.println(modify.getColumn() + "," + modify.getRow() + "," + width + "," + length);
      newCoords.put(f.applyOrientation(newCoordinate, ori, modify, width, length), s.wasHitAt(c));
    }
    Ship<Character> newShip = new AlienShip<Character>(ori, newCoords, s.getName(), newCoordinate, sign, '*');
    return newShip;
  }
}
